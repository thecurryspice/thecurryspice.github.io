<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Timers - Gory Details | Akhil R. Baranwal </title> <meta name="author" content="Akhil Raj Baranwal"> <meta name="description" content="Welcome to my website. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website, computer-architecture"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://thecurryspice.github.io/tutorials/2017-07-15-timers-gory-details/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Akhil R. Baranwal </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item active"> <a class="nav-link" href="/tutorials/">tutorials <span class="sr-only">(current)</span> </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/books/">bookshelf</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Timers - Gory Details</h1> <p class="post-meta"> Created on July 15, 2017 by Akhil Raj Baranwal </p> <p class="post-tags"> <i class="fa-solid fa-calendar fa-sm"></i> 2017   ·   <i class="fa-solid fa-tag fa-sm"></i> tutorial </p> </header> <article class="post-content"> <div id="markdown-content"> <p><sub><em>Last Updated: July 15th, 2017</em></sub></p> <p><em>The following text assumes you have already read the <a href="https://arbaranwal.github.io/tutorial/2017/07/10/timers-basic-concepts.html" title="Basic Concepts explained ever so deeply" rel="external nofollow noopener" target="_blank">previous tutorial</a> and are aware of the basic concepts of timers. If not, I strongly recommend you to read it to have a fair idea of how timers work. Here is a <a href="https://arbaranwal.github.io/tutorial/2017/06/23/atmega328-register-reference.html#reference-table" rel="external nofollow noopener" target="_blank">reference</a> of a lot of registers that you might want to check out, although, most registers concerned with timers will be mentioned here too.</em></p> <hr> <p><br> <br></p> <h2 id="atmega328s-timers">ATmega328’s Timers</h2> <p>The ATmega328 has three timers, with each timer having two channels:<br></p> <p><strong>Timer0 (8-bit)</strong>: This timer is used in elementary functions like <strong>delay()</strong>, <strong>millis()</strong> and <strong>micros()</strong>. Yes, you used Timer0 for your very first sketch on Arduino. Timer0 helped you say <em>Hello World</em> to Electronics, or Embedded for that matter. Take a moment to appreciate timer0. Timer0 FTW!<br> Channels A and B control PD5(pin 5) and PD6(pin 6) respectively.</p> <p><strong>Timer1 (16-bit)</strong>: Using the servo library employs this timer. Since it is 16 bit, it allows for a much better resolution even while measuring larger time scales. For reference, Timer1 will provide 256 times higher resolution while measuring the same amount of time interval as compared to Timer0 (or Timer2).<br> Channels A and B control PB1(pin 9) and PB2(pin 10) respectively.</p> <p><strong>Timer2 (8-bit)</strong>: This timer is a prime example of the typical third guy in a startup who is not so popular. The tone() function uses timer2.<br> Channels A and B control PD3(pin 3) and PB3(pin 11) respectively. <br></p> <h3 id="related-registers">Related Registers</h3> <table> <thead> <tr> <th>Register</th> <th style="text-align: center">Offset</th> <th style="text-align: center">Bit7</th> <th style="text-align: center">Bit6</th> <th style="text-align: center">Bit5</th> <th style="text-align: center">Bit4</th> <th style="text-align: center">Bit3</th> <th style="text-align: center">Bit2</th> <th style="text-align: center">Bit1</th> <th style="text-align: center">Bit0</th> </tr> </thead> <tbody> <tr> <td>TCCR0A</td> <td style="text-align: center">0X44</td> <td style="text-align: center">COM0A1</td> <td style="text-align: center">COM0A0</td> <td style="text-align: center">COM0B1</td> <td style="text-align: center">COM0B0</td> <td style="text-align: center">Reserved</td> <td style="text-align: center">Reserved</td> <td style="text-align: center">WGM01</td> <td style="text-align: center">WGM00</td> </tr> <tr> <td>TCCR0B</td> <td style="text-align: center">0X46</td> <td style="text-align: center">FOC0A</td> <td style="text-align: center">FOC0B</td> <td style="text-align: center">Reserved</td> <td style="text-align: center">Reserved</td> <td style="text-align: center">WGM02</td> <td style="text-align: center">CS02</td> <td style="text-align: center">CS01</td> <td style="text-align: center">CS00</td> </tr> <tr> <td>TIMSK0</td> <td style="text-align: center">0X6E</td> <td style="text-align: center">Reserved</td> <td style="text-align: center">Reserved</td> <td style="text-align: center">Reserved</td> <td style="text-align: center">Reserved</td> <td style="text-align: center">Reserved</td> <td style="text-align: center">OCIEB</td> <td style="text-align: center">OCIEA</td> <td style="text-align: center">TOIE</td> </tr> <tr> <td>TIFR0]</td> <td style="text-align: center">0X35</td> <td style="text-align: center">Reserved</td> <td style="text-align: center">Reserved</td> <td style="text-align: center">Reserved</td> <td style="text-align: center">Reserved</td> <td style="text-align: center">Reserved</td> <td style="text-align: center">OCF0B</td> <td style="text-align: center">OCF0A</td> <td style="text-align: center">TOV0</td> </tr> </tbody> </table> <p><br> I strongly recommend opening this <a href="https://arbaranwal.github.io/tutorial/2017/06/23/atmega328-register-reference.html#tc0-control-register-a" rel="external nofollow noopener" target="_blank">reference</a> in another tab to be clear about register descriptions.<br></p> <hr> <p><br> <br></p> <h2 id="saying-hello-world-again">Saying “Hello World” Again</h2> <p>Let’s start with something as basic as blinking an LED, but using only registers. No fancy functions (with all due respect <strong>and</strong> condolences to <em>delay()</em>).<br> Assuming our ATmega is working at a frequency of 16 MHz, and that we need a delay of 2 milliseconds between each toggle, this is how we decide our variables.<br></p> <p>First, choose a prescalar.<br></p> <table> <thead> <tr> <th style="text-align: center">Presaclar</th> <th style="text-align: center">Frequency</th> <th style="text-align: center">Least Count</th> <th style="text-align: center">Max Time</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">1</td> <td style="text-align: center">16 MHz</td> <td style="text-align: center">62.5 ns</td> <td style="text-align: center">16 us</td> </tr> <tr> <td style="text-align: center">8</td> <td style="text-align: center">2 MHz</td> <td style="text-align: center">500 ns</td> <td style="text-align: center">128 us</td> </tr> <tr> <td style="text-align: center">64</td> <td style="text-align: center">250 KHz</td> <td style="text-align: center">4 us</td> <td style="text-align: center">1.024 ms</td> </tr> <tr> <td style="text-align: center">256</td> <td style="text-align: center">62.5 KHz</td> <td style="text-align: center">16 us</td> <td style="text-align: center">4.096 ms</td> </tr> <tr> <td style="text-align: center">1024</td> <td style="text-align: center">15.625 KHz</td> <td style="text-align: center">64 us</td> <td style="text-align: center">16.384 ms</td> </tr> </tbody> </table> <p>256 seems to be the best choice as it gives higher resolution.<br></p> <p>Next, we calculate the value that corresponds to 2 milliseconds. This gives (2 x 256)/4.096 = 125<br></p> <p>Now 125th reading begins at 124, so our target should be 124.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">DDRB</span> <span class="o">|=</span> <span class="mh">0x01</span><span class="p">;</span> <span class="c1">//set pin 8 as output</span>
  <span class="n">TCCR0B</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">CS02</span><span class="p">);</span>  <span class="c1">//Initialise Timer with prescalar 256</span>
  <span class="n">TCNT0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">//Set timer value to 0x00</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">TCNT0</span> <span class="o">&gt;=</span> <span class="mi">124</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">PORTB</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">//toggle LED</span>
    <span class="n">TCNT0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">//reset counter</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><br> Pretty simple code, yes?<br> But there’s a catch here.<br> If some other function is being carried out <em>while</em> the value in TCNT0 exceeds 124, the <strong>if</strong> condition will not be evaluated exactly at <em>== 124</em>.<br> It is for this reason that an inequality ( &gt;= 124) is used. Doing this prevents the CPU from having to switch the LED in a small window (that is, exactly at 124), otherwise, many missed compares might be witnessed.<br> Still, if another function is taking up huge processing time, it is obvious that the toggling of the LED will be disturbed, because maybe the <strong>if</strong> condition is checked when TCNT0 is way past 124.<br></p> <p>But hey, it’s overkill to buy such a good microcontroller to blink LEDs on the only process thread ATMega328 can boast of. We need a way of automating this process of resetting TCNT0 when it reaches past a certain value. That will allow us to run some other instruction on the main thread.<br> Enter <strong>CTC</strong> mode, or Clear Timer on Compare mode.<br> As the name suggests, it keeps comparing values in OCR0A and TCNT0. Whenever there’s a match, an interrupt is fired and voila! the timer resets automatically. Isn’t that awesome?<br></p> <p>These registers will be used for structuring this automation: TCNT0, OCR0A, TCCR0A, TCCR0B, TIMSK0 and TIFR0.<br></p> <p>We’ll also be needing the functions <strong>sei()</strong> and <strong>cli()</strong>.<br></p> <p><strong>sei()</strong> : Enables global interrupts. Equivalent to:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Bit 7 in SREG register, named 'I',</span>
<span class="c1">//determines whether interrupts are</span>
<span class="c1">//enabled or disabled</span>
<span class="n">SREG</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span>
</code></pre></div></div> <p><br> <strong>cli()</strong> : Disables global interrupts. Equivalent to:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SREG</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span>
</code></pre></div></div> <p><em>Enabling</em> and <em>Disabling</em> Interrupts is just a <strong>masking</strong> process. Actually, there is nothing to stop the hardware from generating an interrupt, but whether the interrupt will be noted or not is what is meant by the terms <em>enabling</em> and <em>disabling</em> an interrupt.</p> <p><br> We’ll also need to include <em>avr/interrupt.h</em> header file to use the interrupts.</p> <p><br></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span>
<span class="p">{</span>
  <span class="cp">#include</span><span class="cpf">&lt;avr/io.h&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;avr/interrupt.h&gt;</span><span class="cp">
</span>
  <span class="n">DDRB</span> <span class="o">|=</span> <span class="mh">0x01</span><span class="p">;</span> <span class="c1">//set pin 8 as output</span>

  <span class="c1">//Choose CTC mode</span>
  <span class="n">TCCR0A</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">WGM01</span><span class="p">);</span>

  <span class="c1">//Initialise Timer with prescalar 256</span>
  <span class="n">TCCR0B</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">CS02</span><span class="p">);</span>

  <span class="c1">//Enable global-interrupts</span>
  <span class="c1">//I is 7th bit</span>
  <span class="n">SREG</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">I</span><span class="p">);</span>

  <span class="c1">//Enable comapre-interrupts</span>
  <span class="n">TIMSK0</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">OCIEA</span><span class="p">);</span>

  <span class="c1">//Setup compare value</span>
  <span class="n">OCR0A</span> <span class="o">=</span> <span class="mi">124</span><span class="p">;</span>

  <span class="c1">//Set timer value to 0x00</span>
  <span class="n">TCNT0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//A vector named TIMER0_COMPA_vect is responsible for notifying about the compare match.</span>
<span class="c1">//We make an Interrupt Service Routine for this vector,</span>
<span class="c1">//which executes everytime the interrupt is fired.</span>
<span class="n">ISR</span><span class="p">(</span><span class="n">TIMER0_COMPA_vect</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">PORTB</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">//toggle LED</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">(){}</span>
</code></pre></div></div> <p>Whenever compare matches occur, the respective interrupt vector is caught by the ISR.<br> The main process is stopped and the ISR is executed first, then the main process continues again.<br> Remember that timing functions like <em>micros()</em>, <em>delay()</em> will be disturbed, and PWM channels on pins 5 and 6 won’t work either as all these use Timer0 to work.<br></p> <p>There’s another interesting thing we can do if we just have to toggle an LED. Recall that channels A and B control PD5(pin 5) and PD6(pin 6) respectively.<br> If we use only pins 5 or 6, we don’t even have to write the ISR!<br></p> <p><br></p> <table> <thead> <tr> <th style="text-align: center">COM0A1</th> <th style="text-align: center">COM0A0</th> <th style="text-align: center">Description</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">0</td> <td style="text-align: center">0</td> <td style="text-align: center">Normal port operation, OC0A disconnected</td> </tr> <tr> <td style="text-align: center">0</td> <td style="text-align: center">1</td> <td style="text-align: center">Toggle OC0A on Compare Match</td> </tr> <tr> <td style="text-align: center">1</td> <td style="text-align: center">0</td> <td style="text-align: center">Clear OC0A on Compare Match</td> </tr> <tr> <td style="text-align: center">1</td> <td style="text-align: center">1</td> <td style="text-align: center">Set OC0A on Compare Match</td> </tr> </tbody> </table> <p><sub><em>OC0A is pin 5 (PD5)</em></sub></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">DDRD</span> <span class="o">|=</span> <span class="mh">0x05</span><span class="p">;</span> <span class="c1">//set pin 5 as output</span>

  <span class="c1">//Choose CTC mode</span>
  <span class="c1">//Toggle OC0A on Compare Match</span>
  <span class="n">TCCR0A</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">WGM01</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">COM0A0</span><span class="p">);</span>

  <span class="c1">//Initialise Timer with prescalar 256</span>
  <span class="n">TCCR0B</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">CS02</span><span class="p">);</span>

  <span class="c1">//Enable global-interrupts</span>
  <span class="c1">//I is 7th bit</span>
  <span class="n">SREG</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">I</span><span class="p">);</span>

  <span class="c1">//Enable comapre-interrupts</span>
  <span class="n">TIMSK0</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">OCIEA</span><span class="p">);</span>

  <span class="c1">//Setup compare value</span>
  <span class="n">OCR0A</span> <span class="o">=</span> <span class="mi">124</span><span class="p">;</span>

  <span class="c1">//Set timer value to 0x00</span>
  <span class="n">TCNT0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">(){}</span>
</code></pre></div></div> <p>This code will toggle the LED on pin 5 automatically! No ISR required.<br></p> <p>These types of toggles are especially useful in creating <em>PWMs</em>, because the pulse doesn’t get affected by any other task and is handled internally by hardware.<br> It’s worth noting again that PWMs on pins 5 and 6 are controlled by Timer0, on pins 9 and 10 by Timer1, and on pins 3 and 11 by Timer2. All timers have two channels, and this is why ATmega328 is said to have <strong>6 PWM channels</strong>.</p> <p>We can obviously try <a href="https://en.wikipedia.org/wiki/Bit_banging" title="I know what you're thinking" rel="external nofollow noopener" target="_blank">bit-banging</a> to produce a crude PWM on other pins, but it will never be as accurate as the ones generated independently by hardware.<br></p> <hr> <p><br> <br></p> <h2 id="a-custom-millis-function">A Custom millis() Function</h2> <p>Let’s write a custom millis() function that returns milliseconds.<br> I’ll demostrate this by using timer0.<br> F_CPU is a macro which stores the frequency of CPU in MHz. This defaults to 16 MHz, but we’ll still use F_CPU to make our code run even if we overclock it.<br> The number of microseconds that would have passed during one overflow is (256 * 1000000) / F_CPU. Com’on you can do the math yourself.<br></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define us_passed_on_overflow ((256 * 1000000) / F_CPU)
</span>
<span class="c1">//for storing microseconds</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">us</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">//for storing milliseconds</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ms</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">//enable global interrupts</span>
<span class="c1">//alternative to SREG |= (1 &lt;&lt; I)</span>
<span class="n">sei</span><span class="p">();</span>

<span class="c1">//configuring the Interrupt Service Routine</span>
<span class="n">ISR</span><span class="p">(</span><span class="n">TIMER0_OVF_vect</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//defined by macro</span>
  <span class="n">us</span> <span class="o">+=</span> <span class="n">us_passed_on_overflow</span><span class="p">;</span>

  <span class="c1">//increment ms accordingly</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">us</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">ms</span><span class="o">++</span><span class="p">;</span>
    <span class="n">us</span> <span class="o">=</span> <span class="n">us</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">millis</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">ms</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><br> It is quite obvious that the above code is a tokenish version of the actually complex millis() function in the Arduino libraries.<br> I encourage you to search for and go through the original library named <em>wiring.c</em>, which contains function definitions for millis(), micros(), delay() and delayMicroseconds().</p> <p>The aim of this article is not to motivate you to program timers this way, no. That would be redundant, if not futile.<br> The aim here is to know and appreciate what’s going on in the background.<br> Take a moment to realise that the CPU has to make 16 x 10<sup>6</sup> <em>idle</em> ticks to produce a 1 second delay.<br> That it takes a total of 3 bytes of data to measure digital time in an AVR.<br> Digital Time, that dictates your projects ever since your first sketch of a blinking LED.<br> Remember that little blinking LED once again, and marvel at how the internals work in sheer accuracy to get that to happen.<br> That all of this is so beautifully abstracted into an elementary chip.<br> And that exponentially more complex tasks are carried out in insanely more intricate processors…</p> <p><br> Welcome to the World of Embedded Electronics!</p> <hr> <p><br> <br></p> <p><em>If you want to extend your mental database to include the other two counters as well, please read sections 20 and 21 of the ATmega328/P <a href="http://www.atmel.com/Images/Atmel-42735-8-bit-AVR-Microcontroller-ATmega328-328P_Datasheet.pdf" rel="external nofollow noopener" target="_blank">datasheet</a> for further details. If the concept of timers is known, it must be a breeze to go through the Timer1’s sections, which is only slightly different. Timer2 is just a copy of Timer0 working on different channels. Datasheets are meant to be read and no one actually expects all this information to be memorised. Just knowing about how things happen will be enough knowledge to implement solutions in problem statements, and datasheets can always be referred for the <strong>gory details</strong></em></p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2025-already/">2025 already, is it?</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/micron-imagination-hiaccel/">Restarting in 2024</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2021/on-finding-your-zima-blue/">On Finding Your Zima Blue</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2021/on-potential-and-capacity/">On Potential and Capacity</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2020/for-the-earth-that-is-dying/">For The Earth That Is Dying</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Akhil Raj Baranwal. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: August 07, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>